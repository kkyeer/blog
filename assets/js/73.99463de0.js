(window.webpackJsonp=window.webpackJsonp||[]).push([[73],{597:function(t,v,_){"use strict";_.r(v);var a=_(6),e=Object(a.a)({},(function(){var t=this,v=t.$createElement,_=t._self._c||v;return _("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[_("h1",{attrs:{id:"oom导致的服务异常且不自动恢复"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#oom导致的服务异常且不自动恢复"}},[t._v("#")]),t._v(" OOM导致的服务异常且不自动恢复")]),t._v(" "),_("p",[t._v("某日，正在愉快的冲浪，收到同事的告警:“xx服务预发环境挂了，高频报超时和404错误，在发布？”")]),t._v(" "),_("p",[t._v("由于是预发环境，且整体影响面不大（只是间歇不可用），有足够的时间慢慢排查，因此暂时没有回滚。")]),t._v(" "),_("h2",{attrs:{id:"_404问题"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_404问题"}},[t._v("#")]),t._v(" 404问题")]),t._v(" "),_("p",[t._v("404错误一般是由于预发环境仅单节点，服务因为FullGC等原因健康检查失败导致被注册中心摘除后，暂时没有服务提供者导致，对于线上环境会快速拉起新容器短暂恢复，对于预发环境一般需要等服务恢复后重新注册，然后又出现问题")]),t._v(" "),_("ul",[_("li",[t._v("查看注册中心事件日志发现确实持续有节点健康检查失败事件")]),t._v(" "),_("li",[t._v("容器内部检查后发现")]),t._v(" "),_("li",[t._v("可以确认问题原因（之一）是服务出现了某些异常导致健康检查失败，考虑到调用方有较多的超时报错，从此处入手是一个不错的思路")])]),t._v(" "),_("h2",{attrs:{id:"健康检查失败叠加双超时的一般思路"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#健康检查失败叠加双超时的一般思路"}},[t._v("#")]),t._v(" 健康检查失败叠加双超时的一般思路")]),t._v(" "),_("p",[t._v("接口调用超时一般分为2种，建连超时（"),_("code",[t._v("connectionTimeout")]),t._v("）和响应读取超时（"),_("code",[t._v("socketReadTimeout")]),t._v("）,按一般经验，当出现某接口RT高时，两者会交替出现")]),t._v(" "),_("ol",[_("li",[_("p",[t._v("最初是接口RT高，调用方报错超时（也有可能不报错，看调用方的容忍度），本服务Tomcat线程堆积")]),t._v(" "),_("ul",[_("li",[t._v("这里与接口RT(ms)，QPS，Tomcat最大线程数3个参数有关，当3者出现如下关系时，会导致Tomcat线程持续堆积，即线程无法即使处理请求并释放到线程池")]),t._v(" "),_("li",[_("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/kkyeer/picbed/QpsRTThread2.svg",alt:"QpsRTThread2"}})]),t._v(" "),_("li",[t._v("注意这里是假定服务只有一个接口，实际上服务同时有很多接口所以会有所偏差")]),t._v(" "),_("li",[t._v("举例，一般来说Tomcat线程池默认200，假设某接口集群QPS为20000，集群规模50，则单节点承受400QPS压力，此时接口RT至少要保持在 200*1000/400=500ms 以下才可保证线程池始终有可用的线程")])])]),t._v(" "),_("li",[_("p",[t._v("Tomcat线程很快达到最大线程数，线程池没有线程来立即处理请求，此时请求排队进行处理，上游"),_("code",[t._v("socketReadTimeout")]),t._v("超时报错逐渐增多")])]),t._v(" "),_("li",[_("p",[t._v("线程堆积到一定程度，开始拒绝TCP连接，此时上游开始报错"),_("code",[t._v("connectionTimeout")]),t._v("，建立连接失败")])]),t._v(" "),_("li",[_("p",[t._v("与此同时，健康检查调用"),_("code",[t._v("/actuator/health")]),t._v("接口也超时，此时被暂时从注册中心摘除")])]),t._v(" "),_("li",[_("p",[t._v("随着被注册中心摘除，新请求暂时不会调用到问题pod，积压请求处理完成后，pod恢复正常，健康检查成功，重新放入注册中心")])]),t._v(" "),_("li",[_("p",[t._v("由于接口RT仍旧存在问题，如此往复")])])]),t._v(" "),_("h2",{attrs:{id:"接口rt高"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#接口rt高"}},[t._v("#")]),t._v(" 接口RT高？")]),t._v(" "),_("p",[t._v("根据上面的分析，碰到双超时出现，首先分析接口RT，90%的情况下通过接口监控定位到特别慢的接口，再结合调用链监控或者性能剖析，定位到具体的代码位置可解决。")]),t._v(" "),_("p",[t._v("但是这次通过接口定位发现所有接口的RT都有大幅上升，一般这种情况下是出现了性能瓶颈导致整体接口性能下降。")]),t._v(" "),_("h2",{attrs:{id:"为什么没有自动恢复"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#为什么没有自动恢复"}},[t._v("#")]),t._v(" 为什么没有自动恢复？")])])}),[],!1,null,null,null);v.default=e.exports}}]);